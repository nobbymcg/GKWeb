/*-
 * #%L
 * media-manager-api-proto
 * %%
 * Copyright (C) 2021 - 2026 Nuance Communications Inc. All Rights Reserved.
 * %%
 * The copyright to the computer program(s) herein is the property of
 * Nuance Communications Inc. The program(s) may be used and/or copied
 * only with the written permission from Nuance Communications Inc.
 * or in accordance with the terms and conditions stipulated in the
 * agreement/contract under which the program(s) have been supplied.
 * #L%
 */

syntax = "proto3";

package nuance.mediamanager.connector.v1.media;

import "nuance/rpc/status.proto";
import "google/protobuf/duration.proto";

option java_multiple_files = true;
option java_package = "com.nuance.rpc.mediamanager.connector.v1.media";

// This service allows a connector to create a stream media to Media Manager.
service MediaService {
  // Creates a media entity to be used for streaming media.
  rpc CreateMedia (CreateMediaRequest) returns (CreateMediaResponse);

  // Streams media to Media Manager. Used by the Media Connector to stream a live recording.
  rpc StreamMedia (stream StreamMediaRequest) returns (StreamMediaResponse);
}

// Input message that defines parameters for [CreateMedia](#CreateMedia).
message CreateMediaRequest {
  // Mandatory. The realm ID of the media.
  string realm_id = 1;
}

// Output message that defines parameters returned by [CreateMedia](#CreateMedia).
message CreateMediaResponse {
  // General operation status.
  nuance.rpc.Status status = 1;

  // The Media URN of the created media entity.
  string media_urn = 2;
}

// Input message that defines parameters for [StreamMedia](#StreamMedia).
message StreamMediaRequest {
  // Optional. The realm ID of the media. Ignored if media_urn is in version 2 format.
  string realm_id = 1;

  // Mandatory. The URN of the media to be streamed.
  string media_urn = 2;

  oneof stream_media_request {
    // Message containing the information about the media. Must be the first message in the stream.
    MediaInfoRequest media_info_request = 100;

    // Message containing a media chunk.
    MediaChunkRequest media_chunk_request = 101;

    // Message indicating the end of stream. Must be the last message in the stream.
    EndOfStreamRequest end_of_stream_request = 102;

    // Message indicating that the stream is paused. Must be sent periodically (once per second).
    MediaPausedRequest media_paused_request = 103;

    // Message indicating that the stream is resumed. Must be followed by a MediaChunkRequest or EndOfStreamRequest.
    MediaResumedRequest media_resumed_request = 104;
  }
}

// Message containing the information about the media.
message MediaInfoRequest {
  // Mandatory. The audio format of the media stream.
  AudioFormat audio_format = 1;
}

// Message containing a media chunk.
message MediaChunkRequest {
  // Mandatory. Media chunk data
  bytes data = 1;

  // Optional. The duration of the media chunk.
  google.protobuf.Duration chunk_duration = 2;

  // Optional. The timestamp of the media chunk relative to the start of the stream.
  // The timestamp should start with 0.
  google.protobuf.Duration chunk_timestamp = 3;
}

// Message indicating the end of stream.
message EndOfStreamRequest {
}

// Message indicating that the stream is paused.
message MediaPausedRequest {
}

// Message indicating that the stream is resumed.
message MediaResumedRequest {
}

// Output message that defines parameters returned by [StreamMedia](#StreamMedia).
message StreamMediaResponse {
  // General operation status.
  nuance.rpc.Status status = 1;
}

// Input message containing the audio format of the media.
message AudioFormat {
  oneof audio_format {
    // Signed 16-bit little endian PCM.
    PCM pcm = 1;
    // G.711 A-law, 8kHz.
    ALaw alaw = 2;
    // G.711 Mu-law, 8kHz.
    ULaw ulaw = 3;
    // G729/G729A
    G729 g729 = 4;
  }
  // Number of channels. i.e. mono audios have one channel, while stereo audios usually have 2 channels.
  uint32 num_channels = 100;
}

// Input message defining PCM audio format.
message PCM {
  // Audio sample rate. Default 0, meaning 8000.
  uint32 sample_rate_hz = 1;
}

// Input message defining ALaw audio format. G.711 audio formats are set to 8kHz.
message ALaw {
}

// Input message defining G729/G729A audio format. G.729/G.729A audio format is set to 8kHz.
message G729 {
}

// Input message defining ULaw audio format. G.711 audio formats are set to 8kHz.
message ULaw {
}
